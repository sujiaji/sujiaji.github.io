<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://sujiaji.github.io/homepage-test/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sujiaji.github.io/homepage-test/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-04-10T15:05:58+00:00</updated><id>https://sujiaji.github.io/homepage-test/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">a post with code</title><link href="https://sujiaji.github.io/homepage-test/blog/2024/test/" rel="alternate" type="text/html" title="a post with code"/><published>2024-04-10T04:09:00+00:00</published><updated>2024-04-10T04:09:00+00:00</updated><id>https://sujiaji.github.io/homepage-test/blog/2024/test</id><content type="html" xml:base="https://sujiaji.github.io/homepage-test/blog/2024/test/"><![CDATA[<p>This theme implements a built-in Jekyll feature, the use of Rouge, for syntax highlighting. It supports more than 100 languages. This example is in C++. All you have to do is wrap your code in markdown code tags:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">c++
</span><span class="n">code</span> <span class="n">code</span> <span class="n">code</span>
<span class="p">```</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>For displaying code in a list item, you have to be aware of the indentation, as stated in this <a href="https://stackoverflow.com/questions/34987908/embed-a-code-block-in-a-list-item-with-proper-indentation-in-kramdown/38090598#38090598">Stackoverflow answer</a>. You must indent your code by <strong>(3 * bullet_indent_level)</strong> spaces. This is because kramdown (the markdown engine used by Jekyll) indentation for the code block in lists is determined by the column number of the first non-space character after the list item marker. For example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">1.</span> We can put fenced code blocks inside nested bullets, too.
<span class="p">
   1.</span> Like this:<span class="sb">

      ```c
      printf("Hello, World!");
      ```

</span><span class="p">   2.</span> The key is to indent your fenced block in the same line as the first character of the line.
</code></pre></div></div> <p>Which displays:</p> <ol> <li> <p>We can put fenced code blocks inside nested bullets, too.</p> <ol> <li> <p>Like this:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p>The key is to indent your fenced block in the same line as the first character of the line.</p> </li> </ol> </li> </ol> <p>By default, it does not display line numbers. If you want to display line numbers for every code block, you can set <code class="language-plaintext highlighter-rouge">kramdown.syntax_highlighter_opts.block.line_numbers</code> to true in your <code class="language-plaintext highlighter-rouge">_config.yml</code> file.</p> <p>If you want to display line numbers for a specific code block, all you have to do is wrap your code in a liquid tag:</p> <p>{% highlight c++ linenos %} <br/> code code code <br/> {% endhighlight %}</p> <p>The keyword <code class="language-plaintext highlighter-rouge">linenos</code> triggers display of line numbers. Produces something like this:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[an example of a blog post with some code]]></summary></entry><entry><title type="html">What is manifold fitting?</title><link href="https://sujiaji.github.io/homepage-test/blog/2024/mf/" rel="alternate" type="text/html" title="What is manifold fitting?"/><published>2024-04-10T04:00:00+00:00</published><updated>2024-04-10T04:00:00+00:00</updated><id>https://sujiaji.github.io/homepage-test/blog/2024/mf</id><content type="html" xml:base="https://sujiaji.github.io/homepage-test/blog/2024/mf/"><![CDATA[<h3 id="overview">Overview</h3> <p>In recent years, there has been a growing interest in non-Euclidean statistical analysis, particularly in the pursuit of recovering a low-dimensional structure, referred to as a manifold, that underlies high-dimensional data. The successful recovery of this manifold is contingent on certain noise concentration conditions. Previous methods tackle this challenge by approximating the manifold based on tangent space estimations at each data sample. While these methods offer theoretical convergence guarantees, they assume either noise-free data or noise with bounded characteristics. In practical scenarios where unbounded noise is common, the tangent space estimations at noisy samples become inherently imprecise, potentially introducing inaccuracies when fitting the manifold.</p> <p>In response to this challenge, our research project introduces a novel approach. Instead of estimating tangent spaces at the original data samples, we directly estimate these spaces at projected points on the underlying manifold. This strategic shift aims to mitigate errors caused by unbounded noise, resulting in more accurate manifold fitting.</p> <p>Our research, encompassing our 2019 paper (yx) and subsequent work in 2023 (ysl), centers on non-Euclidean statistical analysis, specifically the recovery of low-dimensional manifolds from high-dimensional data. Unlike existing methods relying on tangent space estimations at data samples, we directly estimate these spaces at manifold-projected points, enhancing accuracy and addressing unbounded noise. Our initial paper (yx) introduced a practical algorithm for manifold fitting, and our 2023 work (ysl) refines the algorithm and establishes superior error bounds. These contributions significantly advance non-Euclidean statistical analysis.</p> <h3 id="model-setting">Model Setting</h3> <p>Let \(\mathcal{M}\) be a \(d\)-dimensional smooth latent manifold embedded in the ambient space \(\mathbb{R}^D\). In this problem, we focus on a random vector \(Y \in \mathbb{R}^D\) that can be expressed as</p> \[Y = X + \xi,\] <p>where \(X \in \mathbb{R}^D\) is an unobserved random vector following a distribution \(\omega\) supported on the latent manifold \(\mathcal{M}\), and \(\xi \sim \phi_\sigma\) represents the ambient-space observation noise, independent of \(X\), with a standard deviation \(\sigma\). The distribution of \(Y\) can be viewed as the convolution of \(\omega\) and \(\phi_\sigma\), whose density at point \(y\) can be expressed as</p> \[\nu(y) = \int_\mathcal{M} \phi_\sigma(y-x)\omega(x)d x.\] <p>Assume \(\mathcal{Y} = \{y_i\}_{i=1}^N \subset \mathbb{R}^D\) is the collection of observed data points, also in the form of</p> \[y_i = x_i + \xi_i, \quad \text{ for } i = 1,\cdots,N,\] <p>with \((y_i, x_i,\xi_i)\) being \(N\) independent and identical realizations of \((Y,X,\xi)\). Based on \(\mathcal{Y}\), we construct an estimator \(\widehat{\mathcal{M}}\) for \(\mathcal{M}\) and provide theoretical justification for it under the following main assumptions:</p> <ul> <li> <p>The latent manifold \(\mathcal{M}\) is a compact and twice-differentiable \(d\)-dimensional sub-manifold, embedded in the ambient space \(\mathbb{R}^D\). Its volume with respect to the \(d\)-dimensional Hausdorff measure is upper bounded by \(V\), and its reach<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> is lower bounded by a fixed constant \(\tau\).</p> </li> <li> <p>The distribution \(\omega\) is a smooth distribution, with respect to the \(d\)-dimensional Hausdorff measure, on \(\mathcal{M}\).</p> </li> <li> <p>The noise distribution \(\phi_\sigma\) is a Gaussian distribution supported on \(\mathbb{R}^D\) with density function</p> \[\phi_\sigma (\xi)= (\frac{1}{2\pi \sigma^2})^{\frac{D}{2}}\exp{(-\frac{\|\xi\|_2^2}{2\sigma^2})}.\] </li> <li> <p>The intrinsic dimension \(d\) and noise standard deviation \(\sigma\) are known.</p> </li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>A non-negative quantity measuring the curvature of a manifold. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="manifold-fitting"/><category term="manifold-fitting"/><category term="ideas"/><summary type="html"><![CDATA[what are we talking about when we say 'fit' a manifold]]></summary></entry></feed>